# Проект 6.  Сегментирование клиентов онлайн-магазина подарков

## Оглавление
[1. Описание проекта](https://github.com/murattumov/project6/blob/master/README.md#Описание-проекта)

[2. Какой кейс решаем?](https://github.com/murattumov/project6/blob/master/README.md#Какой-кейс-решаем)

[3. Краткая информация о данных](https://github.com/murattumov/project6/blob/master/README.md#Краткая-информация-о-данных)

[4. Этапы работы над проектом](https://github.com/murattumov/project6/blob/master/README.md#Этапы-работы-над-проектом)

[5. Результат](https://github.com/murattumov/project6/blob/master/README.md#Результат)

[6. Краткая информация](https://github.com/murattumov/project6/blob/master/README.md#Краткая-информация)

### **Описание проекта**

Бизнес-задача в области маркетинга. Предстоит произвести сегментацию клиентов на основе их покупательской способности, частоты совершения заказов и срока давности последнего заказа, а также определить оптимальную стратегию взаимодействия с ними.

### **Какой кейс решаем?**
Построить модель кластеризации клиентов на основе их покупательской способности, частоты заказов и срока давности последней покупки, определить профиль каждого из кластеров.

### **Краткая информация о данных**
Датасет содержит все транзакции, произошедшие за период с 01/12/2010 по 09/12/2011, для базирующейся в Великобритании компании, занимающейся розничной онлайн-торговлей. Компания в основном продаёт уникальные подарки на все случаи жизни. Состоит из 541909 строк и 8 признаков: 2 числового типа и 6 типа object. 
Признаки:


= InvoiceNo — номер счёта-фактуры (уникальный номинальный шестизначный номер, присваиваемый каждой транзакции; буква "C" в начале кода указывает на отмену транзакции);
- StockCode — код товара (уникальное пятизначное целое число, присваиваемое каждому отдельному товару);
- Description — название товара;
- Quantity — количество каждого товара за транзакцию;
- InvoiceDate — дата и время выставления счёта/проведения транзакции;
- UnitPrice — цена за единицу товара в фунтах стерлингов;
- CustomerID — идентификатор клиента (уникальный пятизначный номер, однозначно присваиваемый каждому клиенту);
- Country — название страны, в которой проживает клиент.


### **Этапы работы над проектом**

- Базовый анализ и знакомство с данными
  1. Есть пропуски в столбцах Description и CustomerID
  2. Максимальное количество товаров в заказе (Quantity) = 80995. Минимальное количество товаров в заказе (Quantity) = -80995. Что говорит о возвращенных заказах. Также есть товары, которые отдают даром. Нуждаются в дополнительной проверке.
  3. У нас 4372 уникальных клиентов, 37 уникальных стран,

- Предобработка и очистка данных
  1. После удаления пропущенных значений (136534), 406829 строк осталось в таблице.
  2. Число найденных дубликатов: 5225. 401604 строк осталось в таблице.
  3. Все возвраты в транзакциях  InvoiceNo начинаются с символа "С". И все отрицательные значения являются возвратами. 16 процентов заказов в таблице являются возвратами.
  4. Создаем новый столбец QuantityCanceled, в который будет указано количество возвращённого впоследствии товара для каждой транзакции, т.е. количество возвращенного товара записывается в предыдущий заказ этого товара в столбец QuantityCanceled.
  5. Удаляем записи с возвратом. После удаления осталось 392732 записей. 
  6. Также в транзакциях найдены другие 6 уникальных специальных видов транзакций, которые ни о чем нам не говорят. Удаляем их. После удаления осталось 391183 записей.
  7. Также удаляем записи цена товаров которых равна 0. Таких записей меньше 1%. После удаления осталось осталось 391150 записей.


- Разведывательный анализ данных (EDA)

  1. добавляем в датасет общую цену заказа, назовём её TotalPrice.
  2. добавляем в таблицу с транзакциями признаки месяца, даты, дня недели и часа совершения покупки.
  3. график, отражающий количество уникальных клиентов в каждой из стран
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_1.png)
  4. график, отражающий количество поступающих заказов по каждой стране
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_2.png)
  5. график распределения выручки по странам
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_3.png)
  6. график, отражающий распределение суммарной выручки от заказов по месяцам.
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_4.png)
  7. график, отражающий распределение среднего количества заказов по дням недели.
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_5.png)
  8. график, отражающий распределение среднего количества ежедневно поступающих заказов по времени суток (часу совершения транзакции).
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_6.png) 
  

- RFM-сегментация клиентов. Часть I
  
  1. создание RFM-таблицы:
  Recency - для клиента рассчитывается как разница между датой и временем последнего заказа и точкой отсчёта, переведённая в дни; Frequency - рассчитывается как общее количество уникальных заказов, которые совершил  клиент;
  Monetary Value - рассчитывается как общая сумма денег, которую клиент потратил на наши товары (с учетом возвратов).
  2. Удаление из RFM-таблицы записей о клиентах, для признаков Frequency и Monetary квантили которых больше уровня 0.95.
  3. визуализацию нашего трёхмерного пространства признаков.
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_7.png) 
  4. Создаем pipeline, в котором будут следующие шаги:
    - стандартизация с помощью StandardScaler с параметрами по умолчанию;
    - метод главных компонент с двумя компонентами.
  Визуализация пространства главных компонент после декомпозиции.
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_8.png)
  5. с помощью коэффициента силуэта подбираем оптимальное количество кластеров для метода k-means.
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_9.png)
  6. с помощью коэффициента силуэта подбираем оптимальное количество кластеров для метода GaussianMixture.
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_10.png)
  7. выбрав модель с максимальным значением коэффициента силуэта 0.52 обучаем лучшую модель с количеством кластеров, равным 3.
  Визуализация.
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_11.png)
  8. составляем профили кластеров. использование полярной диаграммы.
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_12.png)
  

- RFM-сегментация клиентов. Часть II

  1. Воспользуемся алгоритмом t-SNE и трансформируем RFM-таблицу. Создаем pipeline, в котором будут следующие шаги:
    - стандартизация с помощью StandardScaler с параметрами по умолчанию;
    - алгоритм t-SNE с двумя компонентами, параметрами perplexity=50 и random_state=100.
  Визуализация.
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_13.png)
  2. с помощью коэффициента силуэта подбираем оптимальное количество кластеров для метода k-means, перебирая возможные значения от 3 до 8 включительно.
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_14.png)
  3. с помощью коэффициента силуэта подбираем оптимальное количество кластеров для метода GaussianMixture, перебирая возможные значения от 3 до 8 включительно..
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_15.png)
  4. с помощью коэффициента силуэта подбираем оптимальное количество кластеров для метода алгомеративной кластеризации (AgglomerativeClustering), перебирая возможные значения от 3 до 8 включительно..
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_16.png)
  5. выбрав модель с максимальным значением коэффициента силуэта 0.48 обучаем KMeans как лучшую модель с количеством кластеров, равным 7.
  Визуализация.
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_17.png)
  6. составляем профили кластеров. использование полярной диаграммы.
  ![](https://github.com/murattumov/project6/blob/master/plotly/pr6_18.png)

- RFM-сегментация клиентов. Часть III
Построение модели кластеризации для части клиентов, которые не попали в обучающую выборку. Обучим модель классификации, которая на основе RFM-характеристик будет предсказывать клиентский сегмент.
  1. Разделение исходных данных на тренировочную и тестовую выборки в соотношении 80/20.
  2. С помощью GridSearchCV организуем перебор параметров случайного леса (RandomForestClassifier) на следующей сетке параметров:
  param_grid = {
    'max_depth': range(5, 15),
    'criterion': ['gini', 'entropy'],
    'n_estimators': [100, 200, 500]
}
  Получаем accuracy на тестовом наборе: 0.985.
  3. С помощью GridSearchCV организуем перебор параметров градиентного бустинга (GradientBoostingClassifier) на следующей сетке параметров:

param_grid = {
    'max_depth': range(3, 7),
    'learning_rate': [0.001, 0.01, 0.1],
    'n_estimators': [100, 200, 500]
}
  Получаем accuracy на тестовом наборе: 0.983.
  

### **Результат**

С помощью метода главных компонент с двумя компонентами мы нашли оптимальное количество кластеров лучшей модели k-means для RFM-таблицы. После чего мы составили профили кластеров. 
Также мы использовали алгоритм t-SNE для трансформации RFM-таблицы и нашли оптимальное количество кластеров. Для составления профилей кластеров обучили модель классификации RandomForestClassifier, которая на основе RFM-характеристик будет предсказывать клиентский сегмент.

### **Краткая информация**

****


:arrow_up:[к оглавлению](https://github.com/murattumov/project6/blob/master/README.md#Оглавление)
